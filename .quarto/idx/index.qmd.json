{"title":"CASA0025 Group Project -- Heat Stress Vulnerability Index (HSVI)","markdown":{"headingText":"CASA0025 Group Project -- Heat Stress Vulnerability Index (HSVI)","containsRefs":false,"markdown":"\n## Project Summary \n\n*Fill in the sections below to provide a brief summary of your project. Each section should have no more than 100 words. Do not edit any of the headings.*\n\n### Problem Statement \n\n*What is the problem you’re trying to address using this application?*\n\nUrban areas are becoming increasingly warmer than their surrounding areas known as the Urban Heat Island (UHI) effect (Wu et al., 2021). Moreover, heat stress is the leading cause of weather-related deaths and can exacerbate underlying illnesses (WHO, 2024). Studies have shown that estimates of heat-related mortality vary significantly depending on whether residents are assumed to acclimatise to local or city-wide temperatures (Shindell, 2024). Therefore, a web application that integrates temperature data, acclimatisation factors, and demographic vulnerability at a higher resolution would improve localised policy improvements and safety measures. \n\n\n### End User \n\n*Who are you building this application for? How does it address a need this community has?*\n\nThis application is designed for various stakeholders who play a role in protecting London from extreme heat. These include governing authorities, public health bodies, and infrastructure providers. ​​It allows users to identify heat hotspots across the city in near real-time. This improves on static snapshot data (Arup, 2024), enabling more dynamic heat risk management. The application can also be used to inform city-wide policies, and enable localised public health responses during heat waves. Finally, it can be used to evaluate how infrastructure impacts heat stress and encourage precautionary and safety measures.\n\n\n### Data\n\n*What data are you using?*\n\nGeospatial datasets from various sources are used: Sentinel-2 satellite imagery for NDVI (vegetation health), Landsat 8 Tier 1 for land surface temperature, Ordnance Survey for building mass density, and Nomis census data to capture old age demographics. These datasets are integrated and analysed to produce an index of heat vulnerability across urban areas.\n\n| Layer/Factor | Dataset | Resolution | Timeframe | Link |\n|---------------|---------|------------|-----------|------|\n| Population density (elderly) | census2021-ts007-msoa.csv | Vector (MSOA) | As at 2021 | [ONS Census 2021](https://www.nomisweb.co.uk/sources/census_2021_bulk) |\n| NDVI | Sentinel 2 Bands 4 and 8 | 10m | 3-4 days | [Earth Engine Data Catalog Sentinel-2](https://developers.google.com/earth-engine/datasets/catalog/sentinel-2) |\n| Temperature (LST) | Landsat 8 Surface Temperature Band 10 | 30m | 16 days ; Month filter:6-9 | [Earth Engine Data Catalog Landsat 8](https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T1_L2) |\n| Building height and density | Ordnance Survey National Geographic Database (OS NGD) Buildings | vector | 2025 | [OS NGD Documentation](https://docs.os.uk/osngd/data-structure/buildings) |\n\n### Methodology\n\n*How are you using this data to address the problem?*\n\nThis application was built using Streamlit and integrates with Google Earth Engine (GEE). Data is fetched from GEE (Sentinel-2 for vegetation, Landsat 8 for temperature), OS NGD and the UK census. The index was created by first inverting the NDVI values, since more vegetation lowers heat risk, and then scaling all datasets between 0 and 1 using MinMaxScaler before combining them. Every factor is then weighted equally at 25%, and the weighted scores are summed to generate a final Heat Stress Vulnerability Index (HSVI). The results are then presented through an interactive map, enabling stakeholders to identify areas most at risk.\n\n\n### Interface\n\n*How does your application's interface work to address the needs of your end user?*\n\nThe interface features a dual-panel design for HSVI calculation. The left-control panel allows users to select data aggregated at different geographic levels (LAD or council), date ranges, and map topics (overall index or specific factors like NDVI, temperature, elderly population, and building mass density). The right panel displays responsive interactive choropleth maps and bar charts showing top 10 areas needing prior actions to tackle heat stress. Users can also download CSV files for external analysis. This design helps users identify vulnerable communities and understand specific heat-risk factors, supporting future interventions.\n\n\n## The Application \nEach time users change map layers in application, please use \"Reset APP\" botton to refresh the page to avoid cache problmes.\n\n[Application Website: https://casa0025-test.streamlit.app](https://casa0025-test.streamlit.app)\n\n:::{.column-page}\n\n<iframe src='https://casa0025-test.streamlit.app/?embed=true' width='100%' height='700px'></iframe>\n\n:::\n## How it Works \n\n*Use this section to explain how your application works using code blocks and text explanations (no more than 500 words excluding code):*\n\n[Click here](https://github.com/tariroMashCasa/casa0025) to access the repo to find Home.py which includes all codes for the application.\n\n![Technical Walkthrough](images/flowchart.jpg)\n\n### Vulnerable Population\n\nUrban heat disproportionately affects segments of the population; people over the age of 65 represent the largest of these groups. We use this group as a proxy for vulnerable population groups within our application. The data used to size this group is from the UK 2021 Census. Data is aggregated at the lowest available level of aggregation (MSOA) and is summed together. \n\nThis is then divided by the total population for that location “Total Number of Usual Residents” to arrive at a Percentage of the population aged 65 and over. The rate value is used as part of the HSVI, however, in practice there are minor differences when compared to using absolute counts, so rates are preferred.\n\n\n```py\n# 2️ Convert GeoDataFrame → EE FeatureCollection\n                    if st.session_state.london_boroughs_over_65 is None:\n                        # now we're going to add in the vector data for the london boroughs for number of people over 65 from a geojson file\n                        # london_boroughs_over_65 = gp.read_file('data/london_percentage_of_population_over_65.geojson')#.head(10).to_crs(4326)\n                        london_boroughs_over_65 = pd.read_parquet('data/london_percentage_of_population_over_65.parquet.gzip')\n\n\n\n                        # load the lsoa level geometries\n                        # gdf_lsoas = pd.read_parquet('data/london_lsoas_2011_mapping_file.parquet.gzip')\n                        gdf_lsoas = pd.read_parquet('data/london_msoas_2021_mapping_file.parquet.gzip')\n                        # convert the wkt geometry to a shapely geometry\n                        gdf_lsoas[\"geometry\"] = gdf_lsoas[\"geometry\"].apply(shapely.wkt.loads)\n                        # convert this to a geodataframe\n                        gdf_lsoas = gp.GeoDataFrame(gdf_lsoas, geometry=\"geometry\", crs=4326)\n                        # filter the LAD11NM column to match the users  \n                        gdf_boroughs = gdf_lsoas[gdf_lsoas[\"LAD11NM\"] == st.session_state.selected_council]\n                        gdf_boroughs = gdf_boroughs[[\"MSOA21CD\"]].rename(columns={\"MSOA21CD\":\"geography code\"})\n\n\n                        # do a spatial join to get the vulnerable population data for the selected council\n                        london_boroughs_over_65 = london_boroughs_over_65.merge(gdf_boroughs, on=\"geography code\")\n\n                        # convert the wkt geometry to a shapely geometry\n                        london_boroughs_over_65[\"geometry\"] = london_boroughs_over_65[\"geometry\"].apply(shapely.wkt.loads)\n                        # convert this to a geodataframe\n                        london_boroughs_over_65 = gp.GeoDataFrame(london_boroughs_over_65, geometry=\"geometry\", crs=4326)\n\n\n                        # add this to session state\n                        st.session_state.london_boroughs_over_65 = london_boroughs_over_65\n                    else:\n                        london_boroughs_over_65 = st.session_state.london_boroughs_over_65\n\n\n\n\n                    # calculate the midpoint of london\n                    london_midpoint_latitude, london_midpoint_longitude = london_boroughs_over_65.to_crs(4326).geometry.centroid.y.mean(), london_boroughs_over_65.to_crs(4326).geometry.centroid.x.mean()\n                    \n\n                    # rename columns for the map\n                    london_boroughs_over_65 = london_boroughs_over_65.rename(columns={\"pct_over_65_pop\":\"Population over 65 %\",\n                                                                                      \"total_pop_over_65_years_old\":\"Total Population over 65\",\n                                                                                      \"total_pop\":\"Total Population\"})\n                    london_boroughs_over_65 = london_boroughs_over_65.drop(columns=[\"date\",\"city\"])\n                    # round the % population over 65 to 2 decimal places\n                    london_boroughs_over_65[\"Population over 65 %\"] = (london_boroughs_over_65[\"Population over 65 %\"] * 100).round(2)\n\n                    if st.session_state.london_boroughs_over_65_map is None:\n                        # we'll plot this on a folium map\n                        m = london_boroughs_over_65.explore(\"Population over 65 %\", tiles=\"CartoDB.Positron\", cmap=\"Blues\", scheme=\"Quantiles\", legend_title=\"Population over 65\", style_kwds={'weight': 1})\n```\n\n\n### Normalised Difference Vegetation Index (NDVI)\n\nHealthy vegetation cools surrounding areas through shade and evapotranspiration which is why it is incorporated in the index. Healthy plants absorb red light and reflect near-infrared (NIR) light. NDVI captures the contrast between NIR and Red reflectance, allowing us to identify areas of healthy vegetation. Areas with NDVI values close to 1 indicate healthy vegetation, while low or negative values suggest sparse vegetation. \n\nNDVI is calculated using this formula:\n\n$$\nNDVI = \\frac{(NIR - Red)}{(NIR + Red)}\n$$\n\nWhere:\n\n- $NDVI$: Normalized Difference Vegetation Index  \n- $NIR$: Reflectance in the Near-Infrared band  \n- $Red$: Reflectance in the Red band\n\nSentinel-2 data was cloud-filtered and combined using the median value of the available images in GEE. NDVI values were calculated from band 4 (Red) and band 8 (Near-infrared). Then spatially aggregated by borough using a median reducer at 10m resolution.\n\n```py\n# now we're going to use the lad data to get the NDVI\n                    if st.session_state.gdf_results is None:\n\n\n                        # 2️ Convert GeoDataFrame → EE FeatureCollection\n                        ee_boroughs = geemap.geopandas_to_ee(gdf_boroughs, geodesic=False)\n                        st.session_state.ee_boroughs = ee_boroughs\n                        # 3️ Build Sentinel‑2 NDVI composite\n                        sentinel = (\n                            ee.ImageCollection('COPERNICUS/S2_SR')\n                            .filterBounds(ee_boroughs)\n                            .filterDate(one_year_ago, today)\n                            .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n                            .median()\n                            .clip(ee_boroughs)\n                        )\n\n                        # this was the default code for the NDVI\n                        ndvi = sentinel.normalizedDifference(['B8', 'B4']).rename('NDVI')\n                        st.session_state.ndvi = ndvi\n\n                        # 4️ Sum NDVI per borough\n                        fc_results = ndvi.reduceRegions(\n                            collection=ee_boroughs,\n                            reducer=ee.Reducer.median(),\n                            scale=10,\n                            crs='EPSG:27700'\n                        )\n                        \n                        # 5️⃣Pull results client‑side as GeoJSON → GeoDataFrame\n                        geojson = fc_results.getInfo()\n                        \n                        gdf_results = gp.GeoDataFrame.from_features(geojson['features']).rename(columns={'NAME': 'MSOA Name',\"median\": \"NDVI\"})\n                        # for ndvi we will need to invert these values \n                        gdf_results[\"NDVI\"] = 1 / gdf_results[\"NDVI\"]\n\n                        st.session_state.gdf_results = gdf_results\n\n```\n\n\n### Temperature (LST)\n\nLand Surface Temperature (LST) represents heat energy emitted by land, buildings, and other surfaces, serving as an indirect measure of air temperature during heat waves (United States Environmental Protection Agency, 2025). Using Landsat 8 Surface Temperature Band 10 in GEE, processed LST was derived for summer months (June-September) when peak heat conditions are experienced. \n\nWe filtered out cloudy images, before applying a median reducer and a water mask excluding water bodies to focus on artificial surfaces that retain more heat, relevant to urban populations. Spatial aggregation was finally done at LSOA and Borough levels.\n\n```py\n # load the data and apply the relevant filters and functions\n                    #.filter(ee.Filter.calendarRange(6, 9,'month')) \\  may apply a similar seasonal filter here\n                    if st.session_state.date_range_selection == \"Yes\":\n                        landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \\\n                        .filterDate(st.session_state.user_selected_start_date, st.session_state.user_selected_end_date) \\\n                        .filter(ee.Filter.calendarRange(6, 9, 'month'))\\\n                        .filterBounds(ee_boroughs) \\\n                        .filter(ee.Filter.lt(\"CLOUD_COVER\", 15)) \\\n                        .map(applyScaleFactors) \\\n                        .select('ST_B10').map(celsius) \\\n                        .reduce(ee.Reducer.median()) \\\n                        .clip(ee_boroughs)\n                    elif st.session_state.date_range_selection == \"No\":\n                        landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \\\n                        .filterDate(one_year_ago, today) \\\n                        .filter(ee.Filter.calendarRange(6, 9, 'month'))\\\n                        .filterBounds(ee_boroughs) \\\n                        .filter(ee.Filter.lt(\"CLOUD_COVER\", 15)) \\\n                        .map(applyScaleFactors) \\\n                        .select('ST_B10').map(celsius) \\\n                        .reduce(ee.Reducer.median()) \\\n                        .clip(ee_boroughs)\n                    # mask out water in London to detect more accurate LST result\n                    # Generate a water mask.\n                    water = ee.Image(\"JRC/GSW1_4/GlobalSurfaceWater\").select(\"occurrence\")\n                    notWater = water.mask().Not()\n                    temperature_layer = landsat.updateMask(notWater)\n\n                    st.session_state.temperature_layer = temperature_layer\n\n                    # 4️ Sum NDVI per borough\n                    temperature_results = temperature_layer.reduceRegions(\n                        collection=ee_boroughs,\n                        reducer=ee.Reducer.median(),\n                        scale=10,\n                        crs='EPSG:27700'\n                    )\n                            \n                    # 5️⃣Pull results client‑side as GeoJSON → GeoDataFrame\n                    geojson = temperature_results.getInfo()\n                    \n                    temperature_gdf_results = gp.GeoDataFrame.from_features(geojson['features']).rename(columns={'NAME': 'MSOA Name',\"median\": \"surface_temperature\"})\n\n```\n\n### Building Mass Density\n\nDensely built environments contribute to higher heat absorption and slower cooling. Therefore, Building Mass Density (BMD) is considered as part of the Urban Heat Island (UHI) index. BMD has been calculated at both the LSOA and Borough levels.\n\nThe Ordnance Survey National Geographic Database (OS NGD) was used as the most complete and authoritative building dataset available in Great Britain. OS NGD was chosen over OpenStreetMap (OSM) due to its more comprehensive and consistent height attribution, which is sparse and unreliable in OSM (Bernard et al., 2022).\n\nBMD was calculated using the following formula:\n\n$$\nBmd = \\frac{\\sum (H_i \\times A_i)}{A_{admin}}\n$$\n\nWhere:\n\n-   $Bmd$: Building Mass Density\n-   $H_i$: Height of building $i$ (in metres)\n-   $A_i$: Footprint area of building $i$ (in square metres)\n-   $A_{admin}$: Total area of the administrative region (in square metres)\n\n```py\n# 2️ Convert GeoDataFrame → EE FeatureCollection\n                    if st.session_state.london_boroughs_over_65 is None:\n                        # now we're going to add in the vector data for the london boroughs for number of people over 65 from a geojson file\n                        # london_boroughs_over_65 = gp.read_file('data/london_percentage_of_population_over_65.geojson')#.head(10).to_crs(4326)\n                        london_boroughs_over_65 = pd.read_parquet('data/london_percentage_of_population_over_65.parquet.gzip')\n\n\n\n                        # load the lsoa level geometries\n                        # gdf_lsoas = pd.read_parquet('data/london_lsoas_2011_mapping_file.parquet.gzip')\n                        gdf_lsoas = pd.read_parquet('data/london_msoas_2021_mapping_file.parquet.gzip')\n                        # convert the wkt geometry to a shapely geometry\n                        gdf_lsoas[\"geometry\"] = gdf_lsoas[\"geometry\"].apply(shapely.wkt.loads)\n                        # convert this to a geodataframe\n                        gdf_lsoas = gp.GeoDataFrame(gdf_lsoas, geometry=\"geometry\", crs=4326)\n                        # filter the LAD11NM column to match the users  \n                        gdf_boroughs = gdf_lsoas[gdf_lsoas[\"LAD11NM\"] == st.session_state.selected_council]\n                        gdf_boroughs = gdf_boroughs[[\"MSOA21CD\"]].rename(columns={\"MSOA21CD\":\"geography code\"})\n\n\n                        # do a spatial join to get the vulnerable population data for the selected council\n                        london_boroughs_over_65 = london_boroughs_over_65.merge(gdf_boroughs, on=\"geography code\")\n\n                        # convert the wkt geometry to a shapely geometry\n                        london_boroughs_over_65[\"geometry\"] = london_boroughs_over_65[\"geometry\"].apply(shapely.wkt.loads)\n                        # convert this to a geodataframe\n                        london_boroughs_over_65 = gp.GeoDataFrame(london_boroughs_over_65, geometry=\"geometry\", crs=4326)\n\n\n                        # add this to session state\n                        st.session_state.london_boroughs_over_65 = london_boroughs_over_65\n                    else:\n                        london_boroughs_over_65 = st.session_state.london_boroughs_over_65\n\n\n\n\n                    # calculate the midpoint of london\n                    london_midpoint_latitude, london_midpoint_longitude = london_boroughs_over_65.to_crs(4326).geometry.centroid.y.mean(), london_boroughs_over_65.to_crs(4326).geometry.centroid.x.mean()\n                    \n\n                    # rename columns for the map\n                    london_boroughs_over_65 = london_boroughs_over_65.rename(columns={\"pct_over_65_pop\":\"Population over 65 %\",\n                                                                                      \"total_pop_over_65_years_old\":\"Total Population over 65\",\n                                                                                      \"total_pop\":\"Total Population\"})\n                    london_boroughs_over_65 = london_boroughs_over_65.drop(columns=[\"date\",\"city\"])\n                    # round the % population over 65 to 2 decimal places\n                    london_boroughs_over_65[\"Population over 65 %\"] = (london_boroughs_over_65[\"Population over 65 %\"] * 100).round(2)\n\n                    if st.session_state.london_boroughs_over_65_map is None:\n                        # we'll plot this on a folium map\n                        m = london_boroughs_over_65.explore(\"Population over 65 %\", tiles=\"CartoDB.Positron\", cmap=\"Blues\", scheme=\"Quantiles\", legend_title=\"Population over 65\", style_kwds={'weight': 1})\n\n```\n\n\n### Heat Stress Vulnerability Index (HSVI)\n\nThen we combine four factors above to calculate the index:\n\n```py\n# okay so now we're going to normalise the data values  using sklearn min max scaler\n                    scaler = MinMaxScaler()\n                    # first we'll get the columns we want to normalise\n                    columns_to_normalise = [\"ndvi\",\"surface_temperature\",\"pct_over_65_pop\",\"building_density\"]\n                    for column in columns_to_normalise:\n                        raw_index_values_gdf_boroughs[f\"{column}_normalised\"] = scaler.fit_transform(raw_index_values_gdf_boroughs[[column]])\n                    # st.write(\"Normalised dataframe\")\n                    # st.dataframe(raw_index_values_gdf_boroughs)\n                    # ------------------------------------------------------------\n                    normalised_columns = [x for x in raw_index_values_gdf_boroughs.columns if \"normalised\" in x]\n                    for column in normalised_columns:\n                        # now we're going to weight this by 25% for each of the normalised values\n                        raw_index_values_gdf_boroughs[f\"{column}_weighted\"] = raw_index_values_gdf_boroughs[column] * 0.25\n                    # st.write(\"Weighted dataframe\")\n                    weighted_df = raw_index_values_gdf_boroughs[[\"borough_name\"]+[x for x in raw_index_values_gdf_boroughs.columns if \"weighted\" in x] + [\"geometry\"]]\n                    # st.dataframe(weighted_df)\n                    # ------------------------------------------------------------\n                    # now lastly we're going to sum these up to get the final index values\n                    weighted_df[\"index_value\"] = weighted_df[[x for x in weighted_df.columns if \"weighted\" in x]].sum(axis=1)\n                    weighted_columns = [x for x in weighted_df.columns if \"weighted\" in x]\n                    # st.write(\"Final index dataframe\")\n                    # st.dataframe(weighted_df.rename(columns={\"borough_name\":\"Location\"}).drop(columns=[\"geometry\"]))\n                    # ------------------------------------------------------------\n\n```\n\n## Reference\n\nArup. (2024) Urban heat snapshot. Available at: [https://www.arup.com/insights/publication-urban-heat-snapshot/](https://www.arup.com/insights/publication-urban-heat-snapshot/) (Accessed: 20 April 2025). \n\nBernard, J. et al. (2022) ‘Estimation of missing building height in OpenStreetMap data: a French case study using GeoClimate 0.0.1’, Geoscientific Model Development, 15(19), pp. 7505–7532. Available at: [(https://doi.org/10.5194/gmd-15-7505-2022)](https://doi.org/10.5194/gmd-15-7505-2022).\n\nShindell, D., Hunter, R., Faluvegi, G., & Parsons, L (2024). ‘Premature deaths due to heat exposure: The potential effects of neighborhood-level versus city-level acclimatization within US cities’, GeoHealth, 8. \n\nUnited States Environmental Protection Agency (EPA) (2025) Measuring Heat Islands. Available at: [https://www.epa.gov/heatislands/measuring-heat-islands](https://www.epa.gov/heatislands/measuring-heat-islands) (Accessed: 25 April 2025).\n\nWilby, R.L. (2003).  ‘Past and projected trends in London's urban heat island’, Weather, 58: 251-260. \n\nWorld Health Organization. (2024) Heat and health. Available at: [https://www.who.int/news-room/fact-sheets/detail/climate-change-heat-and-health](https://www.who.int/news-room/fact-sheets/detail/climate-change-heat-and-health) (Accessed: 20 April 2025). \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"monokai.theme","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","book":{"title":"CASA0025 Final Assessment","author":"Group Name","date":"01/01/2024","chapters":["index.qmd"],"repo-actions":["edit"],"downloads":["pdf","epub"],"sharing":["twitter","facebook"],"favicon":"favicon.ico","sidebar":{"logo":"casa_logo.png"}},"theme":{"dark":"darkly","light":"cosmo"},"code-copy":true,"linkcolor":"#34a832"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}